# VEXL - Vector Expression Language

**VEXL** is a programming language where *everything is a vector*. It unifies scalars, arrays, matrices, tensors, trees, and graphs under a single `Vector<T, D>` type, enabling fractal computing through nested vector abstractions.

## âœ¨ Key Features

- ğŸ”¢ **Universal Vector Type**: Everything is `Vector<T, D>` - from scalars to tensors
- ğŸŒ€ **Fractal Computing**: Self-similar computation through nested vector abstractions
- âˆ **Generators**: Store algorithms, not data - near-infinite logical storage
- âš¡ **Implicit Parallelism**: Pure functions automatically parallelize via effect typing
- ğŸ“ **Dimensional Types**: Compile-time dimension checking prevents shape errors
- ğŸ”„ **Cooperative Scheduler**: Fair load balancing across CPU cores
- ğŸ¯ **Effect System**: Track purity, I/O, mutability, async, and fallibility

## ğŸš€ Current Status

**Phase 1: Foundation** - In Progress

âœ… Complete workspace with 9 crates  
âœ… Core types (Vector, Generator, Effect)  
âœ… Lexer with 40+ tokens  
âœ… Complete AST  
âœ… Type inference foundation  
âœ… Cooperative load-balancing scheduler  
â±ï¸ Build time: 6.55s  
âœ… All tests passing

## ğŸ“¦ Project Structure

```
vexl/
â”œâ”€â”€ crates/
â”‚   â”œâ”€â”€ vexl-core/         # Vector<T,D>, Generator trait, Effect types
â”‚   â”œâ”€â”€ vexl-syntax/       # Lexer (logos) + Parser (chumsky) + AST
â”‚   â”œâ”€â”€ vexl-types/        # Hindley-Milner + dimensional + effect inference
â”‚   â”œâ”€â”€ vexl-ir/           # VEXL Intermediate Representation (VIR)
â”‚   â”œâ”€â”€ vexl-codegen/      # LLVM backend (planned)
â”‚   â”œâ”€â”€ vexl-runtime/      # CooperativeScheduler, GC, caching
â”‚   â”œâ”€â”€ vexl-driver/       # CLI, REPL, build pipeline
â”‚   â”œâ”€â”€ vexl-lsp/          # Language Server Protocol
â”‚   â””â”€â”€ vexl-pkg/          # Package manager
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ framework/         # Test infrastructure
â”‚   â””â”€â”€ conformance/       # Conformance test suite
â””â”€â”€ docs/                  # Documentation
```

## ğŸ› ï¸ Building

```bash
# Install Rust (if not already installed)
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

# Build the workspace
cargo build --workspace

# Run tests
cargo test --workspace

# Check code
cargo check --workspace
```

## ğŸ“– Language Examples

### Vector Literals
```vexl
let scalar = 42
let vector = [1, 2, 3]
let matrix = [[1, 2], [3, 4]]
```

### Comprehensions
```vexl
let squares = [x*x | x <- [1..10]]
```

### Generators (Infinite Sequences)
```vexl
let fibs = fix f => [0, 1, ...[f[i-1] + f[i-2] | i <- [2..]]]
let first_10 = fibs |> take(10)
```

### Pipelines
```vexl
data |> map(f) |> filter(p) |> reduce(+) |> print
```

### Effect Types
```vexl
pure fn add(a: Int, b: Int) -> Int { a + b }  // Auto-parallelizable
io fn read_file(path: String) -> String { ... }  // Not parallelized
```

## ğŸ¯ Design Principles (OPTIBEST Framework)

VEXL follows the OPTIBEST framework for premium software design:

1. **Functional Excellence**: Builds and tests pass
2. **Efficiency**: CooperativeScheduler for optimal CPU utilization
3. **Robustness**: Strong type system with dimensional checking
4. **Scalability**: Generator-based storage for infinite data
5. **Maintainability**: Clear module separation, comprehensive tests
6. **Innovation**: Fractal computing, universal vector type
7. **Elegance**: Minimal complexity for maximum expressiveness

## ğŸ”„ Cooperative Scheduler

VEXL uses a **Cooperative Load Balancing Scheduler** (renamed from "work-stealing" for clarity):

- Idle threads *help* busy threads by taking tasks from their queues
- Fair work distribution across all CPU cores
- Lock-free task queues using `crossbeam-deque`
- Optimal CPU utilization without thread starvation

## ğŸ“‹ Roadmap

### Phase 1: Foundation (In Progress)
- âœ… Workspace setup
- âœ… Core types
- âœ… Lexer & AST
- â­ï¸ Complete parser
- â­ï¸ Full type inference

### Phase 2: Compilation (Planned)
- VIR lowering
- LLVM backend
- SIMD optimization
- Runtime expansion

### Phase 3: Tooling (Planned)
- CLI commands
- REPL
- LSP server
- VS Code extension

### Phase 4: Testing & QA (Planned)
- Conformance suite
- Property-based tests
- Benchmarks

### Phase 5: Documentation (Planned)
- Language reference
- Standard library docs
- Getting started guide

## ğŸ¤ Contributing

VEXL is designed following the OPTIBEST framework. Contributions should:

- Maintain or improve code quality
- Include comprehensive tests
- Follow Rust best practices
- Respect the cooperative scheduler terminology

## ğŸ“œ License

MIT OR Apache-2.0

## ğŸ™ Acknowledgments

Built with:
- [Rust](https://www.rust-lang.org/) - Systems programming language
- [logos](https://github.com/maciejhirsz/logos) - Lexer generator
- [chumsky](https://github.com/zesterer/chumsky) - Parser combinator library
- [crossbeam](https://github.com/crossbeam-rs/crossbeam) - Concurrency tools
- [tower-lsp](https://github.com/ebkalderon/tower-lsp) - LSP framework
- LLVM (planned) - Code generation backend

---

**Status**: Active Development | **First Release**: TBD | **Language Version**: 0.1.0
